# D2D Protocol - Money Flow Architecture

## Executive Summary

D2D Protocol is a DeFi platform on Solana that allows **Stakers (Backers)** to stake SOL to earn rewards, while the protocol uses that SOL to **fund deployments** for developers. This document describes in detail the money flow within the system.

---

## 1. Main Account Balances

### 1.1 TreasuryPool - Important Balance Fields

```rust
// === MAIN BALANCE ===
pub liquid_balance: u64;           // SOL available for deployments & withdrawals
pub total_deposited: u64;          // Total SOL staked by all stakers
pub reward_pool_balance: u64;      // Reward pool to pay stakers
pub platform_pool_balance: u64;    // Platform fee pool for admin

// === DEBT TRACKING ===
pub total_borrowed: u64;           // Total SOL currently borrowed for deployments
pub total_recovered: u64;          // Total SOL recovered from rent
pub total_debt_repaid: u64;        // Total debt repaid

// === REWARD TRACKING ===
pub reward_per_share: u128;        // Accumulator for reward distribution
pub pending_undistributed_rewards: u64;  // Rewards waiting to be distributed
pub total_stake_duration_weight: u128;   // Total weight by staking duration
```

### 1.2 Relationship Between Balances

```
┌──────────────────────────────────────────────────────────────────┐
│              TREASURY PDA (Physical SOL Balance)                  │
├──────────────────────────────────────────────────────────────────┤
│  liquid_balance          │ For deployments + withdrawals         │
│  + reward_pool_balance   │ For staker rewards                    │
│  + platform_pool_balance │ For admin operations                  │
│  + pending_undistributed │ Rewards waiting to be distributed     │
│  ≈ Total Lamports        │                                       │
└──────────────────────────────────────────────────────────────────┘
```

---

## 2. Staker Deposit Flow (stake_sol)

### 2.1 Flow Diagram

```
┌─────────────┐     SOL Transfer      ┌─────────────────┐
│   Staker    │ ───────────────────▶  │  Treasury PDA   │
│   Wallet    │                       │  liquid_balance │
└─────────────┘                       └─────────────────┘
                                              │
                              ┌───────────────┼───────────────┐
                              ▼               ▼               ▼
                        ┌──────────┐   ┌───────────┐   ┌───────────┐
                        │total_    │   │reward_    │   │platform_  │
                        │deposited │   │pool (1%)  │   │pool(0.1%) │
                        └──────────┘   └───────────┘   └───────────┘
```

### 2.2 State Changes

```typescript
treasury_pda.lamports += amount;
treasury_pool.total_deposited += amount;
treasury_pool.liquid_balance += amount;

// Fee calculation (if applicable)
reward_fee = (amount * 100) / 10000;     // 1%
platform_fee = (amount * 10) / 10000;    // 0.1%

lender_stake.deposited_amount += amount;
lender_stake.reward_debt = deposited_amount * reward_per_share;
```

### 2.3 First Depositor Protection

To prevent **first-depositor arbitrage** (first person claiming all accumulated rewards):

```typescript
if (total_deposited_before == 0 && reward_pool_balance > 0) {
    // DO NOT add to reward_per_share immediately
    // Move to pending for gradual distribution
    pending_undistributed_rewards += reward_pool_balance;

    // Emit event for tracking
    emit!(RewardsMovedToPending { amount, reason: "first_depositor_protection" });
}
```

### 2.4 Duration Tracking

```typescript
if (!is_new_deposit) {
    duration = current_time - lender_stake.last_action_at;
    weight_delta = deposited_amount * duration;
    lender_stake.stake_duration_weight += weight_delta;
    treasury_pool.total_stake_duration_weight += weight_delta;
}

lender_stake.last_action_at = current_time;
```

---

## 3. Reward Calculation Model

### 3.1 Reward Per Share Accumulator

D2D uses the **Reward Per Share** model similar to Jito/Solayer:

```
PRECISION = 1,000,000,000,000 (10^12)

// When there are new rewards (from fees):
delta = (reward_amount * PRECISION) / total_deposited
reward_per_share += delta

// Claimable rewards for a staker:
accumulated = deposited_amount * reward_per_share
claimable = (accumulated - reward_debt) / PRECISION
```

### 3.2 Duration-Weighted Bonus

Stakers who stake longer receive additional rewards from `pending_undistributed_rewards`:

```typescript
stake_duration_weight = deposited_amount * (current_time - last_action_at)
total_stake_duration_weight = Σ(all stakers' weights)
duration_bonus = pending_undistributed_rewards * (staker_weight / total_weight)
```

---

## 4. Claim Rewards Flow

### 4.1 Two Sources of Rewards

```
┌─────────────────────────────────────────────────────────────────┐
│                     CLAIMABLE REWARDS                            │
├────────────────────────────┬────────────────────────────────────┤
│   BASE REWARDS             │   DURATION BONUS                   │
│   (reward_per_share)       │   (pending_undistributed)          │
├────────────────────────────┼────────────────────────────────────┤
│ Source: reward_pool_balance│ Source: pending_undistributed      │
│ Formula:                   │ Formula:                           │
│ (amount * rps - debt)      │ pending * (weight/total_weight)    │
│ / PRECISION                │                                    │
└────────────────────────────┴────────────────────────────────────┘
                    │
                    ▼
            ┌───────────────┐
            │ TOTAL CLAIM   │
            │ = base + bonus│
            └───────────────┘
```

### 4.2 Claim Process

```typescript
weight_delta = lender_stake.update_duration_weight(current_time);
base_claimable = calculate_claimable_rewards(deposited_amount, reward_debt);
duration_bonus = pending_undistributed_rewards * staker_weight / total_weight;
total_claimable = base_claimable + duration_bonus;

lender_stake.claimed_total += total_claimable;
lender_stake.reward_debt = deposited_amount * reward_per_share;
lender_stake.stake_duration_weight = 0;  // Reset after claim
lender_stake.pending_rewards = 0;

treasury_pool.reward_pool_balance -= base_claimable;
treasury_pool.pending_undistributed_rewards -= duration_bonus;
treasury_pool.total_claimed_rewards += base_claimable;

reward_pool_pda → lender_wallet (total_claimable)
```

---

## 5. Withdrawal Flow

### 5.1 Immediate Withdrawal (unstake_sol)

When `liquid_balance >= withdrawal_amount`:

```
┌─────────────┐     SOL Transfer      ┌─────────────────┐
│   Staker    │ ◀─────────────────── │  Treasury PDA   │
│   Wallet    │                       │  liquid_balance │
└─────────────┘                       └─────────────────┘
```

```typescript
require!(liquid_balance >= amount);
require!(!lender_stake.has_queued_withdrawal());

weight_delta = lender_stake.update_duration_weight(current_time);

lender_stake.deposited_amount -= amount;
treasury_pool.total_deposited -= amount;
treasury_pool.liquid_balance -= amount;

treasury_pda → lender_wallet (amount)
```

### 5.2 Queued Withdrawal

When `liquid_balance < withdrawal_amount` (liquidity is locked in deployments):

```
┌─────────────┐                       ┌─────────────────┐
│   Staker    │ ─── Request ────────▶ │  Withdrawal     │
│   Wallet    │                       │  Queue          │
└─────────────┘                       └─────────────────┘
                                              │
                                      Wait for rent recovery
                                              │
                                              ▼
                                      ┌───────────────┐
                                      │  Process when │
                                      │  liquidity    │
                                      └───────────────┘
```

```typescript
queue_entry = WithdrawalQueueEntry {
    position: withdrawal_queue_tail,
    staker: requester,
    amount: withdrawal_amount,
    queued_at: current_time,
    processed: false,
};

lender_stake.queued_withdrawal = amount;
lender_stake.queue_position = position;
treasury_pool.withdrawal_queue_tail += 1;
treasury_pool.queued_withdrawal_amount += amount;

// NOTE: amount is NOT deducted from total_deposited until processed
// Staker continues receiving rewards
```

### 5.3 Cancel Queued Withdrawal

Staker can cancel queued withdrawal:

```typescript
require!(lender_stake.has_queued_withdrawal());

treasury_pool.queued_withdrawal_amount -= amount;
lender_stake.queued_withdrawal = 0;
lender_stake.queue_position = 0;
queue_entry.processed = true;
```

---

## 6. Developer Payment Flow

### 6.1 Subscription Payment

Developers pay fees to maintain program deployments:

```
┌─────────────┐     SOL Transfer      ┌─────────────────┐
│  Developer  │ ───────────────────▶  │   Dev Wallet    │
│   Wallet    │                       │  (treasury.dev) │
└─────────────┘                       └─────────────────┘
                                              │
                                   credit_reward_pool()
                                              │
                                              ▼
                                      ┌───────────────┐
                                      │ reward_pool   │
                                      │ balance += fee│
                                      └───────────────┘
```

### 6.2 Fee Structure

```typescript
1. Service Fee (one-time): deploy_request.service_fee
2. Monthly Fee: deploy_request.monthly_fee * months
3. Monthly Borrow Fee (1%): borrowed_amount * 100 / 10000

subscription_fees → reward_pool_balance  // For stakers
platform_fees → platform_pool_balance    // For admin
```

---

## 7. Deployment & Debt Flow

### 7.1 Fund Temporary Wallet (Borrowing)

When admin funds deployment for developer:

```
┌─────────────────┐    lamport mutation   ┌───────────────────┐
│  Treasury PDA   │ ────────────────────▶ │ Temporary Wallet  │
│  liquid_balance │                       │ (ephemeral_key)   │
└─────────────────┘                       └───────────────────┘
```

```typescript
require!(liquid_balance >= deployment_cost);
require!(check_utilization_limit(deployment_cost));

treasury_pool.liquid_balance -= deployment_cost;
treasury_pool.total_borrowed += deployment_cost;
treasury_pool.active_deployment_count += 1;

deploy_request.borrowed_amount = deployment_cost;
deploy_request.ephemeral_key = temporary_wallet;
deploy_request.expected_rent_recovery = deployment_cost * 80%;
```

### 7.2 Pool Utilization Limit

Protect stakers by limiting 80% utilization:

```typescript
MAX_UTILIZATION_BPS = 8000;  // 80%

check_utilization_limit(deployment_amount):
    remaining = liquid_balance - deployment_amount;
    min_reserve = total_deposited * 20 / 100;
    return remaining >= min_reserve;
```

### 7.3 Rent Recovery (Debt Repayment)

When program expires and is closed:

```
┌───────────────────┐   close_any()    ┌─────────────────┐
│   Program Data    │ ───────────────▶ │  Treasury PDA   │
│   (rent lamports) │                  │  recovered_rent │
└───────────────────┘                  └─────────────────┘
                                               │
                               ┌───────────────┴───────────────┐
                               ▼                               ▼
                       ┌───────────────┐               ┌───────────────┐
                       │ Debt Repayment│               │ Excess Rewards│
                       │ → liquid_bal  │               │ → reward_pool │
                       └───────────────┘               └───────────────┘
```

```typescript
recovered = program_data.lamports;
remaining_debt = borrowed_amount - repaid_amount;
debt_repayment = min(recovered, remaining_debt);
excess_to_rewards = recovered - debt_repayment;

deploy_request.repaid_amount += debt_repayment;
deploy_request.actual_rent_recovered = recovered;
deploy_request.recovery_ratio_bps = (recovered / borrowed) * 10000;

treasury_pool.total_recovered += recovered;
treasury_pool.total_debt_repaid += debt_repayment;
treasury_pool.total_borrowed -= debt_repayment;
treasury_pool.active_deployment_count -= 1;
treasury_pool.liquid_balance += debt_repayment;

if (excess_to_rewards > 0) {
    credit_fee_to_pool(excess_to_rewards, 0);
}
```

---

## 8. Pending Rewards Distribution

### 8.1 Gradual Distribution

Admin/cron periodically calls `distribute_pending_rewards`:

```typescript
distribute_pending_rewards(distribution_percentage_bps):
    amount_to_distribute = pending_undistributed_rewards * percentage / 10000;
    delta = (amount_to_distribute * PRECISION) / total_deposited;
    reward_per_share += delta;
    pending_undistributed_rewards -= amount_to_distribute;
    return amount_to_distribute;
```

---

## 9. Dynamic APY Calculation

APY increases when utilization is high to attract more deposits:

```typescript
// Constants
DEFAULT_BASE_APY_BPS = 500;           // 5% base APY
MAX_UTILIZATION_BPS = 8000;           // 80%
TARGET_UTILIZATION_BPS = 6000;        // 60%
MAX_APY_MULTIPLIER_BPS = 30000;       // 3x max

calculate_current_apy():
    utilization = total_borrowed / total_deposited;

    if utilization >= 80%:
        multiplier = 3.0x  // Max
    else if utilization >= 60%:
        // Linear from 1.5x → 3x
        multiplier = 1.5 + 1.5 * ((utilization - 60%) / 20%)
    else:
        // Linear from 1x → 1.5x
        multiplier = 1.0 + 0.5 * (utilization / 60%)

    return base_apy * multiplier;
```

---

## 10. Complete Money Flow Diagram

```
                         ┌─────────────────────────────────────┐
                         │           D2D PROTOCOL              │
                         └─────────────────────────────────────┘

  STAKERS                         TREASURY                      DEVELOPERS
  ═══════                         ════════                      ══════════

  ┌──────────┐    stake_sol    ┌──────────────────────────┐
  │  Staker  │ ───────────────▶│     TREASURY PDA         │
  │  Wallet  │                 │ ┌──────────────────────┐ │
  └──────────┘                 │ │   liquid_balance     │ │◀─── rent recovery
       │                       │ │   (deposits +        │ │        │
       │                       │ │    repayments)       │ │        │
       │    unstake_sol        │ └──────────┬───────────┘ │        │
       │◀───────────────────── │            │             │        │
       │   (if liquid avail)   │            │ fund_       │        │
       │                       │            │ temporary   │        │
       │    queue_withdrawal   │            ▼ wallet      │        │
       │ ─────────────────────▶│ ┌──────────────────────┐ │        │
       │   (if no liquid)      │ │   Temp Wallet        │─┼────────┤
       │                       │ │   (for deployment)   │ │        │
       │                       │ └──────────────────────┘ │        │
       │                       │                          │        │
       │                       │ ┌──────────────────────┐ │        │
       │    claim_rewards      │ │   reward_pool        │ │        │
       │◀──────────────────────│ │   balance            │◀┼────────┤
       │                       │ │   (staker rewards)   │ │  subscription
       │                       │ └──────────────────────┘ │  fees
       │                       │                          │        │
       │                       │ ┌──────────────────────┐ │  ┌───────────┐
       │                       │ │   platform_pool      │ │  │ Developer │
       │                       │ │   balance            │ │  │  Wallet   │
       │                       │ │   (admin ops)        │ │  └───────────┘
       │                       │ └──────────────────────┘ │
       │                       │                          │
       │                       │ ┌──────────────────────┐ │
       │  duration_bonus       │ │   pending_undist     │ │
       │◀──────────────────────│ │   rewards            │ │
       │                       │ │   (fair dist)        │ │
       │                       │ └──────────────────────┘ │
       │                       └──────────────────────────┘

  ┌──────────────────────────────────────────────────────────────────┐
  │                         KEY FORMULAS                              │
  ├──────────────────────────────────────────────────────────────────┤
  │  claimable = (amount × rps - debt) / PRECISION                   │
  │  duration_bonus = pending × (staker_weight / total_weight)       │
  │  utilization = total_borrowed / total_deposited                  │
  │  recovery_ratio = actual_recovered / borrowed × 100%             │
  └──────────────────────────────────────────────────────────────────┘
```

---

## 11. Security Invariants

### 11.1 Balance Invariants

```
✓ liquid_balance ≤ total_deposited (can't lend more than staked)
✓ total_borrowed ≤ 80% of total_deposited (utilization limit)
✓ reward_pool_balance ≥ protected_rewards (staker claims protected)
✓ queued_withdrawal_amount ≤ total_deposited - liquid_balance
```

### 11.2 Overflow Protection

All arithmetic operations use `checked_*` methods:

```rust
// Example
self.total_deposited = self.total_deposited
    .checked_add(amount)
    .ok_or(ErrorCode::CalculationOverflow)?;
```

### 11.3 Reentrancy Protection

- All state updates happen BEFORE transfers
- CPI calls are at the end of instructions

---

## 12. Error Codes Reference

| Error | Description |
|-------|-------------|
| `InsufficientLiquidBalance` | liquid_balance < withdrawal amount |
| `PoolUtilizationTooHigh` | Would exceed 80% utilization |
| `WithdrawalAlreadyQueued` | Staker already has pending withdrawal |
| `NoQueuedWithdrawal` | Trying to cancel non-existent queue |
| `NoStakersForDistribution` | total_deposited = 0 when distributing |
| `RewardDebtExceedsAccumulated` | Invalid reward calculation state |

---

## 13. Summary

### Money Sources:
1. **Staker Deposits** → `liquid_balance` + `total_deposited`
2. **Subscription Fees** → `reward_pool_balance`
3. **Rent Recovery** → `liquid_balance` (debt) + `reward_pool` (excess)

### Money Uses:
1. **Deployments** ← `liquid_balance` (borrowed with 80% limit)
2. **Withdrawals** ← `liquid_balance`
3. **Reward Claims** ← `reward_pool_balance` + `pending_undistributed`

### Key Protection Mechanisms:
1. **80% Utilization Limit** - Ensures 20% always available for withdrawals
2. **First Depositor Protection** - Prevents reward sniping
3. **Duration-Weighted Rewards** - Incentivizes long-term staking
4. **Withdrawal Queue** - Handles low liquidity gracefully
5. **Debt Tracking** - Transparent borrowed/recovered accounting
